# [Vue CLI](https://cli.vuejs.org/)

CLI (Command Line Interface) нужен для того, чтобы можно было эффективно управлять большим проектом, когда весь проект будет разбит на множество модулей.  Это своего рода конструктор, в котором будут как собственные модули, так и готовые решения, такие как webpack, препроцессоры css и тд.. 

В конечной версии приложения vue CLI присутствовать не будет,
он является средством для разработки

## Установка [node.js](https://nodejs.org/en)

Для того, чтобы установить CLI, первым делом необходимо устанавливаем [node.js](https://nodejs.org/en/download/current) с дефолтными настройками. Будет использоваться пакетный менеджер npm. Дополнительные примочки устанавливать не нужно.

## [Установка Vue CLI](https://cli.vuejs.org/guide/installation.html)
```
npm install -g @vue/cli
```
`-g` – флаг для установки в глобальную директорию:
```
C:\Users\username\AppData\Roaming\npm\node_modules
```
без флага – в папку node_modeles текущей директории. 

Подробнее [здесь](https://cli.vuejs.org/guide/installation.html).


## [Создание нового проекта](https://cli.vuejs.org/guide/creating-a-project.html)

```
vue create <project_name>
```
- Babel компилирует ES6 в ES5
- ESLint помагает избежать ошибок и придежриваться стандартов

Так же можно создать проект, используя User Interface:
```
vue ui          
```

затем, в том же UI добалвять нужные плагины.

Подробнее [здесь](https://cli.vuejs.org/guide/creating-a-project.html).

## [Запуск Vue CLI](https://cli.vuejs.org/guide/cli-service.html)

Для запуска проекта нужно перейти в директорию проекта и выполнить
```
npm run serve
```

# Структура проекта

`package.json` – файл, в котором содержится информация о проекте:
- `dpendencies` – библиотеки, которые будут в конечном приложении;
- `devDependencies` – библиотеки используемые для разработки.

---

`package-lock.json` – моментальный "снимок" всего дерева зависимостей, по данному файлу загружаются инструменты.

---

`node_modules` – здесь находятся все библиотеки и их зависимости.

---

`public` – директория, к которой обращается сервер, после запуска проекта:
- `index.html` – файл, в который автоматически добавляются скрипты вместо
  `<!-- built files will be auto injected -->`
в общем случае, это будет файл `app.js`, который будет получен в результате компиляции проекта (можно сказать, что сюда будет вставлен скрипт`main.js` из папки `src`). Этот файл попадает в конечную версию приложения, со всеми зависимостями, в том числе изображениями.

---

`assets` – здесь располагаются статические файлы (картинки и прочее).

---

`src` – директория с исходным кодом проекта.

`main.js` включает в себя весь код, который мы написали, а так же фреймворки и библиотеки, прежде чем быть подключенным к `index.html`. 


# [Application](https://vuejs.org/guide/essentials/application.html)

## Создание приложения

При создании **экземпляра приложения** (*applications instance*) функцией `createApp` (например, в файле `main.js`), первым аргументом передается **корневой компонент** (*root component*) (например, `App.vue`):

```js
import { createApp } from 'vue'
import App from './App.vue' 
const app = createApp(App)
```

Компоненты образуют древовидную структуру.

```js
const app = createApp(App)      
app.mount('#app')                   // и связываем с тегом id="app"
```
## [Монтирование приложения](https://vuejs.org/guide/essentials/application.html#mounting-the-app)

Экземпляр приложения не будет рендериться пока не будет вызван метод `mount()`. Он ожидает аргумент контейнера, который может быть элементом DOM или селектором:

```js
app.mount('#app')
```

Содержимое корневого компонента приложения будет отображаться внутри элемента контейнера (блок с `id="app"`). Сам элемент контейнера не считается частью приложения.

Метод `mount()` всегда следует вызывать после завершения всех настроек приложения и регистрации объектов. Также обратите внимание, что его возвращаемое значение, в отличие от методов регистрации объектов, представляет собой экземпляр корневого компонента, а не экземпляр приложения.

>Перед монтированием приложения может потребоваться подключить плагины (store, router и тд), зарегистрировать глобальные компоненты и произвести прочие конфигурации. 

# [Components](https://vuejs.org/guide/essentials/component-basics.html)

Компоненты позволяют нам разделить пользовательский интерфейс на независимые и повторно используемые части и думать о каждой части отдельно. Обычно приложение организовано в виде дерева вложенных компонентов:

![](https://vuejs.org/assets/components.7fbb3771.png)

Каждый компонет имеет отдельную область видимости, и объявленные переменные, функции или классы не видны за пределами компонента, если не экспортировать их явно.

## Структура компонента

Компоненты создаются в папке `components` с расширением `*.vue`.

В компоненте по крайней мере имеются две секции:
- шаблон `html`, который помещается в тэг `<templates></templates>`
- скрипт, который описывает объект компонента `<script></script>` 

Обычно имеется и третья секция `<style></style>`, описывающая стили, используемые в данном компоненте.

Для того, чтобы стили прописанные в данном компоненте не применялись к другим компонентам, к тегу `<style>` добавляется атрибут `scoped`: `<style scoped>`, такое поведение достигается за счет того, что к тегам и к селекторам компонента будет добавляться уникальный data-атрибут.

> Бывает уместным исользовать две секции `style`: одну для локального использования, и вторую для глобального.

## [Локальная регистрация компонента](https://vuejs.org/guide/components/registration.html#local-registration)

Чтобы использовать дочерний компонент (`TaskItem.vue`), нам нужно импортировать его в родительский компонент:

```js
import TaskItem from './TaskItem'
```

Чтобы предоставить импортированный компонент нашему шаблону, нам нужно зарегистрировать его с помощью опции `components`. После этого компонент будет доступен как тег с использованием ключа, под которым он зарегистрирован (`<TaskItem />`).

## [Глобальная регистрация компонента](https://vuejs.org/guide/components/registration.html#global-registration)


Глобальная регистрация компонента осуществляется в методом `component`, экземпляра приложения (`app` в файле `main.py`). Первым аргументом передается имя компонента в виде строки (под этим именем компонент будет доступен в проекте), вторым аргументом – регистрируемый компонент.

```js
import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome'
app.component('fa-icon', FontAwesomeIcon)
```


# Draft

Передача данных дочерним компонентам
------------------------------------

Свойство data в компонентах должно быть в виде функции, который 
возвращает объект, содержащий данные, методы и события:
data() {
    return {
        info: [
            {id: 1, title: 'Title 1', isActive: false},
            {id: 2, title: 'Title 2', isActive: true},
            {id: 3, title: 'Title 3', isActive: false},
        ]
    }
},

Передача таких данных осуществляется однонаправленно - от родителя к 
потомку через динамические входные параметры, как значения атрибута 
html-тега, указывающего на дочерний компонент. В этом случае, значение
будет передано в виде строки. Если передается не единственное значение, 
а итерируемый объект, то к атрибуту применяется v-bind, в таком случае 
значение будет передано в виде итерируемого объекта (массив, объект...):
<SubComp :info="info" /> // к атрибуту info биндится массив info из data

кроме того, можно осуществить итеративную передачу элементов объекта:
<SubComp v-for="item in info" :item="item" :key="item" />
в этом случае в родительском компоненте будет создано множество элементов
дочернего компонента <SubComp />, каждый из который получит по одному
элементу итерируемого объекта.

для того, чтобы была возможность отслеживать идентичность каждого такого
элемента, и манипулировать им, необходимо указать атрибут :key, который
будет содержать уникальное значение (в данном случае, эти будет index).
В частности, целесообразно использовать значение id записи из базы данных.

далее переходим в файл дочернего компонента и создаем в экспортируемом 
объекте поле props. Это поле будет представлять собой массив, в котором
прописываются передаваемые данные от родительского компонента

export default {
    props: ['info'],
}

кроме того, если передается объект, то можно произвести валидацию полей:
https://ru.vuejs.org/v2/guide/components-props.html#Валидация-входных-параметров

если получен итерируемый объект, то путем итераций, можно будет внести
эти данные в шаблон дочернего компонента. Например:

<li v-for="(item, index) in info" :key="index">{{ index + 1 }}. {{ item }}</li>

данные из props можно и дальше отправлять дочерним компонентом по
аналогичной схеме.


Передача сигналов родительским компонентам
------------------------------------------

Дочерние компоненты воздействуют на данные родителей посредством событий.

вызывать один action внутри другого action в самом store можно так:
someAction(context) {context.dispatch('anotherAction')}


# Установка приложений

npm install --save axios vue-axios
npm install --save mitt
npm install vuex@next --save

npm i --save @fortawesome/fontawesome-svg-core
npm i --save @fortawesome/free-solid-svg-icons
npm i --save @fortawesome/vue-fontawesome@prerelease

https://github.com/developit/mitt