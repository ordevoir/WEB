# Models

Модель должна быть подклассом класса `Model` из модуля `django.db.models`. Отдельным полям модели присваиваются объекты классов, представляющих поля соответствующих типов и объявленных в том же модуле `django.db.models`. Параметры полей указываются в конструкторах классов полей в виде значений именнованных параметров:

```python
class Task(models.Model):
    title = models.CharField(max_length=150, verbose_name='Title', db_index=True)
    discribe = models.TextField(null=True, blank=True, verbose_name='Discribtion')
    created = models.DateTimeField(auto_now_add=True, db_index=True, verbose_name='Created')
```

Один такой класс соответствует одной таблице в БД, т.е. является моделью этой таблицы.

Для того, чтобы по моделям были созданы таблицы, необходимо произвести миграции.

Модель необходимо зарегистрировать на админском сайте.

## Типы полей

Примеры полей ([model fields types](https://docs.djangoproject.com/en/5.0/ref/models/fields/#field-types); наверху страницы есть список типов полей):

- [`CharField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#charfield) – обычное строковое поле фиксированной длины `max_lenght`.
- [`TextField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#textfield) – текстовое поле неограниченной длины, или memo-поле.
- [`FloatField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#floatfield) – поле для хранения вещественных чисел.
- [`DateTimeField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#datetimefield) – поле для хранения отметки даты и времени. Присвоив параметру `auto_now_add` конструктора значение `True`, мы предпишем Django при создании новой записи записывать в это поле текущие дату и время. Также имеются поля [`DateField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#datefield) и [`TimeField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#timefield).
- [`SlugField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#slugfield) – слаг, т.е. строка, однозначно идентифицирующая запись и применяемая в качестве части интернет-адреса. В отличие от `CharField` имеет свои специальные валидаторы.
- [`PositiveIntegerField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#positiveintegerfield) – положительные целые числа (4 байта). Значения от 0 до 2147483647 безопасны во всех базах данных, поддерживаемых Django.
- [`BigIntegerField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#bigintegerfield) – целые числа (8 байт). Может хранить значения от -9223372036854775808 до 9223372036854775807.
- [`BooleanField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#booleanfield) – хранит значения `True` / `False`.


## Параметры конструкторов

Примеры параметров ([field options](https://docs.djangoproject.com/en/5.0/ref/models/fields/#field-options); наверху страницы есть список параметров):


- [db_index](https://docs.djangoproject.com/en/5.0/ref/models/fields/#db-index) – при присваивании ему значения `True` укажет создать для этого поля индекс.
- [blank](https://docs.djangoproject.com/en/5.0/ref/models/fields/#blank) – значение `True` позволяет остаялять поле пустым; если при этом [`null`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#null) также задан как `True` то при этом в базу будет записываться значение `NULL` (подробнее см. Дронов с.91).
- [unique](https://docs.djangoproject.com/en/5.0/ref/models/fields/#unique) – если задано значение `True`, то поле должно быть уникальным по всей таблице. Поля с флагом `unique=True` автоматически индексируются, поэтому можно не задвать явно `db_index=True`.


## Поля отношений

Всего есть три поля отношений: `ForeignKey` (Many-to-One Field), `ManyToManyField` и `OneToOneField`. Эти классы позволяют установить соответствующие отношения между парами моделей (таблиц).

### [`ForeignKey`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#foreignkey)

Класс `ForeignКey` представляет поле внешнего ключа, в котором фактически будет храниться ссылка на запись из другой (внешней) таблицы.

Предположим, что помимо объявленного выше класса модели `Task` имеется еще модель `Activity`. Тогда, определяя поле класса `Task` следующим образом:

```python
activity = models.ForeignKey('Activity', on_delete=models.SET_NULL, to_field='title', related_name='tasks')
```

тогда, поле `activity` может принимать значения только и множества записей таблицы `Activity`, т.е. любая запись таблицы `Task` может быть связанна с единственной записью таблицы `Activity`. Так как в данном случае имеем дело с отношением Many-to-One, то неограниченное количество записей таблицы `Task` может быть связано с единственной записью из таблицы `Activity`. Модель, в которой создается поле `ForeignKey` называется `вторичной`, а модель, которая служит внешним ключом – называют `первичной`. В отличие от отношений `ManyToManyField` и `OneToOneField`, отношение `ForeignKey` не является симметричным.

Первым аргументом (`to`) конструктору класса `ForeignKey` передается класс первичной модели. Сделать это можно двумя способами:

- передать ссылку на класс, если класс внешней модели (`Activity`) объявлен перед данным классом (т.е. имя внешнего класса без кавычек);

- передать строку с именем класса если данная модель объявлена раньше внешней (т.е. имя внешнего класса в кавычках: `"Activity"`).

Параметр [`on_delete`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.ForeignKey.on_delete) управляет удалениями записей данной модели, после удаления записи внешней модели (`Activity`), с которой они были связаны:
- `CASCADE` – удаляет все связанные записи модели (`Task`).
- `SET_NULL` – заносит в поле внешнего ключа всех связанных записей `NULL`.
- `SET(<значение>)` – заносит в поле внешнего ключа указанное значение; можно вписать ссылку на функцию, возвращающую значение (подробнее, в см. Дронов с.53; другие значения приведены в описании параметра по ссылке).

При установки отношения `ForeignKey` во внешней модели также будет создано поле, предназначенное для доступа к связанным записям данной модели. Название этого поля задается в параметре [`related_name`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.ForeignKey.related_name), (по умолчанию, в данном примере, будет автоматически присвоено имя `task_set`).

Какое значение будет сохранено в поле `ForeignKey`, чтобы можно было идентифицировать связанную запись из таблицы `Activity`? По умолчанию, в поле `ForeignKey` будет храниться первичный ключ связанной записи (`pk` или `id`). Однако, можно указать и другое поле модели `Activity`, если оно является уникальным (`unique=True`), задав параметр [`to_field`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#django.db.models.ForeignKey.to_field).

Полю внешнего ключа рекомендуется давать имя в соответствии с той моделью, с которой устанавливается отношение. Например, для внешнего класса `User` можно создать поле с именем `user`. На уровне базы данных поле внешнего ключа при этом будет предатсвленно полем `user_id`. В веб-форме такое поле будет представляться раскрывающимся списком, содержащим строковые представления записей первичной модели.

Вместо того, чтобы ссылаться на модель `User` напрямую, мы должны делать это, используя метод `django.contrib.auth.get_user_model()`:

```python
from django.contrib.auth import get_user_model

user = models.ForeignKey(get_user_model(), on_delete=models.CASCADE, related_name='tasks')
```
    
Метод `get_user_model()` возвращает действующую модель, указанную в настройках приложения или стандартную модель `User`, в случае, если не изменялась.

### [`ManyТoManyField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#manytomanyfield)

Поле `ManyТoManyField` позволяет связать произвольное количество записей одной модели с произвольным количеством записей другой модели (обе модели здесь выступают как равноправные, и определить, какая из них первичная, а какая вторичная, не представляется возможным). Т.е. тношение является симметричным. В конструкторе класса `ManyТoManyField` отсутствует параметр `on_delete`.

### [`OneToOneField`](https://docs.djangoproject.com/en/5.0/ref/models/fields/#onetoonefield) 

Поле `OneToOneField` соединяет одну запись данной модели с одной записью внешней модели. Такие связи служат для объединения моделей, одна из которых хранит данные, дополняющие данные из другой модели.

## [Методы моделей](https://docs.djangoproject.com/en/5.0/ref/models/instances/)

Переопределяя метод [`save()`](https://docs.djangoproject.com/en/5.0/ref/models/instances/#saving-objects), можно изменить стандартное поведение сохранения записи. Важно при этом не забывать вызывать метод суперкласса. Можно даже отменять сохранение по условию:

```python
def save(self, *args, **kwargs):
    indicator # вычисляем значение в теле функции
    ...
    if indicator:
        super().save(*args, **kwargs)
```

Метод [`delete()`](https://docs.djangoproject.com/en/5.0/ref/models/instances/#deleting-objects) позволяет также кастомизировать удаление объекта.

>В Django 4.2 добавлены асинхронные версии этих метово `asave()` и `adelete()`.

Для отладки может быть полезным переопределение метода `__str__()`:

```python
def __str__(self):
    return self.title
```

## `Meta` – параметры модели

Параметры самой модели описываются различными атрибутами класса `Meta`, вложенного в класс модели и не являющегося производным ни от какого класса. Вот список этих атрибутов: 
- `verbose_name` – название сущности, хранящейся в модели, которое будет выводиться на экран. Если не указано, используется имя класса модели;
- `verbose_name_piurai` – название набора сущностей, хранящихся в модели, которая будет выводиться на экран. Если не указано, используется имя класса модели во множественном числе;
- `ordering` – параметры сортировки записей модели по умолчанию. Задаются в виде последовательности имен полей, по которым должна выполняться сортировка, представленных строками. Если перед именем поля поставить символ `-`, то порядок сортировки будет обратным. 

```python
class Meta:
    verbose_name = 'Task'           # в единственном числе
    verbose_name_plural = 'Tasks'   # во множественном числе
    ordering = ['-created']          # сортировка записей
```

>Подробнее Дронов с 102


# Views

Контроллер обрабатывает запросы, приходящие по определенному URL, направляя данные от клиента к системе и обратно. Ответ в Django формируется в виде html страницы. Для этого контроллер использует шаблонизатор. В REST вместо шаблонизатора используется сериализатор, при помощи которого формируется ответ в виде JSON файла. При этом, от клиента также может быть получен файл JSON, на основе которого контроллер будет производить действия, используя сериализатор.

Контроллеры могут быть реализованы как в виде функций, так и в виде классов. Здесь будет представлен только второй вариант. Классы контроллеров должны наследоват класс `View` из модуля `django.views.generic`. Однако, здесь будут рассматриваться только контроллеры для REST API, и классы должны будут наследовать класс `APIView` из модуля `rest_framework.views`.

Так как по одному и тому же URL могут приходить запросы с различными HTTP-методами (GET, POST и тд), в классе контроллера могут быть определены соответствующие методы (`get()`, `post()` и т.д.). Когда матшрутизатор будет назначать контроллер, будет вызван метод, соответствующий HTTP-методу запроса. 

>Если был получен запрос по методу PATCH, а метод `patch()` отсутствует, будет выполнен метод `put()`.

При вызове метода контроллера, первым аргументом метод получает всегда объект запроса (для этого принято использовать имя `request`). 


## `get()`

Рассмотрим простой пример:

```python
from rest_framework.views import APIView
from rest_framework.response import Response
from .serializers import TaskSerializer
from .models import Task

class TaskList(APIView):
    def get(self, request):
        tasks = Task.objects.filter(user=request.user)
        # tasks = Task.objects.all()
        serializer = TaskSerializer(tasks, many=True)
        return Response(serializer.data, status=status.HTTP_200_OK)
```

Метод `get()` будет вызван при GET запросе. Из таблицы БД, соответствующей модели `Task`, будут извлечены записи, соответствующие имени клиента (которое содержится в поле `user` объекта запроса `request`). Далее создается объект сериализатора. В контруктор сериализатора первым аргументом передается список записей (вернее, не список, а объект класса `django.db.models.query.QuerySet`), полученных из таблицы `Task`. Так как был передан список записей, а не одна запись, необходимо задать второй аргумент (`many`) равным `True`. Данные, которые нужно отправить в ответ клиенту, содержатся в поле `data` сериализатора. Метод `get()` возвращает объект класса `Response`, в конструктор которого первым аргументом передаются данные для клиента, а вторым (`status`) – статус ответа.

## `delete()`

Рассмотрим пример с параметризованным URL. Примером может быть такой URL: https://somename.com/somepath/4. Здесь параметром URL является число 4. Если URL является параметризованным, то метод получит в качестве второго аргумента значение параметра (обычно используется имя `pk` – *primary key*):

```python
class TaskDetail(APIView):
    def delete(self, request, pk):
        task = Task.objects.get(id=pk, user=request.user)
        tasks = Task.objects.filter(superTask=task)
        for t in tasks:
            t.superTask = task.superTask
            t.save()
        task.delete()   
        return Response(status=status.HTTP_204_NO_CONTENT)
```

В данном примере (при DELETE запросе) производится удаление записи в таблице модели `Task`. Первым делом выбирается объект записи, соответствующий параметру URL и имени клиента, и записывается в переменную `task`. Далее в переменную `tasks` собираются все записи из `Task`, для которых поле `superTask` равно записи `task` (по внешнему ключу `ForeignKey`). В цикле перебираются объекты записей из `tasks` и в поле `superTask` записывается значение поля `superTask` записи объекта `task`. Для того, чтобы эти изменения, произведенный над объектами записей, фактически произвелись над таблицей в БД, необходимо вызвать метод `save()` у объектов записей. Метод `delete()` объекта записи, производит удаление записи из БД. В ответ клиенту отправляется только статус ответа (в таких случаях используется статус `204`).

Так как в этом примере мы не получали данных от клиента, и не отправляли ему данные, а лишь использовались URL и статус ответа, нам не пришлось использовать сериализаторы.
 
## `post()`

При десериализации данных из клиентского запроса, конструктор класса сериализатора получает данные из запроса в именнованный аргумент `data`.

```python
class TaskList(APIView):
    def post(self, request):
        serializer = TaskSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save(user=request.user)
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
```

Метод [`save()`](https://www.django-rest-framework.org/api-guide/serializers/#saving-instances) сериализатора используется либо для создания новой записи, либо для обновления записи, в зависимости от контекста. Если при создании объекта сериализатора, в конструктор не был передан объект записи, то вызов метода `save()` приведет к созданию записи. Если же в конструктор сериализатора был передан объект записи, то вызов `save()` произведет обновление этой записи (см. пример ниже). 

При вызове метода `save()` сериализатора, мы передали также именованный аргумент `user=request.user`. Это позволяет [вводить дополнительные данные в момент сохранения](https://www.django-rest-framework.org/api-guide/serializers/#passing-additional-attributes-to-save). В данном случае, в поле `user` записи будет внесено имя текущего пользователя, так как этого поля не было в данных запроса (`request.data`).

Метод [`is_valid()`](https://www.django-rest-framework.org/api-guide/serializers/#validation) сериализатора используется при десериализации данных, перед их записью в БД. Он выполняет проверку входных данных и подтверждает, что они содержат все необходимые поля и имеют правильные типы. 

Если процесс валидации успешен, метод `is_valid()` создает в объекте сериализатора поле `validated_data` – словарь, содержащий провалидированные данные, и возвращает значение `True`. Этот словарь используется для создания или обновления данных в базе данных. 

Если же при валидации произошла ошибка, то `is_valid()` создает в объекте сериализатора поле `errors` – словарь, содержащее сообщение об ошибке, и возвращает значение `False`. Примером такого словаря может быть что-то вроде

```
{'email': ['Enter a valid e-mail address.'], 'created': ['This field is required.']}
```

Инструкцию по более гибкому использованию валидации, см. в [документации](https://www.django-rest-framework.org/api-guide/serializers/#validation).


## `patch()`

Метод `pathch()` вызывается для PATCH запросов, и позволяет изменять отдельные поля записей. 

```python
class TaskDetail(APIView):
    def patch(self, request, pk):
        task = Task.objects.get(id=pk)
        serializer = TaskDetailSerializer(task, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(status=status.HTTP_202_ACCEPTED)
        return Response(serializer.data, status=status.HTTP_400_BAD_REQUEST)
```

В данном примере мы получаем в запросе как данные (в `request.data`), так и параметр из URL (`pk`). Так как в конструктор сериализатора передается (помимо данных) объект записи (`task`), то метод `save()` сериализатора произведет обновление записи (а не создание). Для того, чтобы можно было произвести частичное обновление, устанавливаем также  `partial=True`. По параметру URL идентифицируется запись, а в данных запроса содержатся данные тех полей, которые нужно обновить. 

>Вообще говоря, можно непосредственно создать объект записим, передать его полям данные из данных запроса (используя модуль `json`) и сохранить запись без сериализатора. Однако, сериализаторы существенно упрощают этот процесс и позволяют сделать его более надежным.


# [Serializers](https://www.django-rest-framework.org/api-guide/serializers/)

Сериализаторы преобразуют объекты записи (модели) и другие типы данных в формат, который можно передать через сеть, и наоборот. Они упрощают процесс преобразования данных в формат JSON или XML, что позволяет легко обмениваться данными между клиентом и сервером. 

В REST сериализаторы работают очень похоже на классы `Form` и `ModelForm` в Django. Класс сериализатора должен быть производным от класса `Serializer` или `ModelSerializer` из модуля `rest_framework.serializers`.

Класс [`Serializer`](https://www.django-rest-framework.org/api-guide/serializers/#serializers) предоставляет мощный, общий способ управления выводом ответов. Он позволяет преобразовывать сложные данные, такие как наборы запросов и экземпляры моделей, в собственные типы данных Python. Затем эти данные могут быть легко преобразованы в JSON, XML или другие типы содержимого.

Класс [`ModelSerializer`](https://www.django-rest-framework.org/api-guide/serializers/#modelserializer) позволяет быстро создавать сериализаторы (дочерние классы), которые работают с объектами записей и клиентскими запросами. Далее будем описывать сериализаторы, построенные на базе класса `ModelSerializer`.

>Сериализаторы принято определять в модуле serializers.py.

Класс `ModelSerializer` (в отличие от `Serializer`) производит также:
- автоматическую генерацию набора полей, на основе заданной модели;
- автоматическую генерацию валидаторов для сериализатора, такие как `unique_together`;
- включает простые дефолтные реализации методов `create()` и `update()`, отвечающие за создание и обновление записей моделей.

Определим простейший сериализатор, связанный с моделью `Task`, определенной в самом начале:

```python
class TaskSerializer(ModelSerializer):
    class Meta:
        model = Task
        fields = ["id", "title", "discribe", "user"]

```

Теперь, в views.py можно будет импортировать этот сериализатор и создать объект сериализатора , передав в конструктор объект записи:

```python
serializer = TaskSerializer(task)
```

Тогда сериализованные данные будут доступны в поле `data`, для отправки клиенту в формате JSON. При этом, в данных не будет поля `created`, и других полей, которые были определены в модели `Task`, но будет поле `id`, которое было добавлено автоматически, при создании таблицы в БД.

>В конструктор сериализатора можно также передать набор записей (как это было сделано выше в `get()`).

## Сериализация Related Fields

По-умолчанию, для ключей вшеншнего поля (например, поле `user` модели `Task`) сериализатор в качестве значения будет использовать `id` (или `pk`) связанной внешней записи (модели `User`), если не был задан мараметр `to_field` в конструкторе `ForeignKey` поля модели `Task`. Для того, чтобы вместо этого использовалось, скажем, поле `username` внешней записи, можно воспользоваться сериализатором `SlugRelatedField`:

```python
class TaskSerializer(ModelSerializer):
    user = SlugRelatedField(slug_field="username", read_only=True)
    class Meta:
        model = Task
        fields = ["id", "title", "discribe", "user"]

```

>Если в модели был задан параметр to_field для данного поля, то использовать `SlugRelatedField` уже не нужно.

Также следует иметь в виду, что вместо `id` внешнего поля будет использоваться поле `username` не только при сериализации, но и при десериализации: когда данные JSON, полученные от клиента будут превращаться в объекты моделей, для создания или обновления записей. Поэтому, для задания поля внешнего ключа `user`, необходимо будет использовать не `id` записи `User`, а его `username`.

>Следует иметь в виду, что имя, используемое при создании объекта `SlugRelatedField`, должно соответствовать имени поля модели (в данном случае, `user`).

## `exclude`

Вместо `fields` можно использовать `exclude`, в котором перечисляются поля, которые *не* нужно сериализовать, но надо иметь в виду, что тогда не будут сериализовано поле `pk`, а также поля, которые не определялись явным образом в модели (например, поля, которые появились в данной модели, когда в другой (или в этой же) модели создавались поля, относяшиеся `related` к данной модели). Однако, если такое поле будет нарямую сериализовано сериализатором `SlugRelatedField`, то оно не будет исключено.

## Композиция сериализаторов

В общем случае, внутри сериализатора можно использовать другие сериализаторы (как это было сделано с `SlugRelatedField`). Мы можем использовать и пользовательский сериализатор. Пусть, к примеру, в модели `Tag` есть поле `tasks`, которое неявно было определено за счет поля `ForeignKey` в модели `Task`, связанного с моделью `Tag`:

```python
class Task(models.Model):
    ...
    tag = models.ForeignKey('Tag', on_delete=models.SET_NULL, related_name='tasks')
    ...
```

Тогда, для сериализации поля `tasks` можно использовать сериализатор модели `Task`:

```python
class TagSerializer(ModelSerializer):
    user = SlugRelatedField(slug_field='username', read_only=True)
    tasks = TaskSerializer(many=True, required=False)
    class Meta:
        model = Tag
        field = ["user", "tasks"]
```

Здесь задан параметр `many=True`, так как в поле `tasks` может быть множество отношений с записями `Task`. Задание параметра `required=False` позволяет десериализовать данные запроса, не содержащие поле `tasks`.

Впрочем, мы могли бы создать и отдельный сериализатор, который можно было бы использовать в сериализаторе `TagSerializer` вместо `TaskSerializer`:

```python
class TaskTitleSerializer(ModelSerializer):
    class Meta:
        model = Task
        fields = ('title', 'superTask')
```

## Преобразование данных

Иногда необходимо производить проебразования данных, прежде чем записать их в базу данных, и наоборот, прежде чем отправлять клиенту. Пусть к примеру клиент присылвает данные в виде массива, а мы хотим запистаь их в базу MySQL, которая не поддерживает поля массивов. Одним из решений является запись массива в виде строки (если это не вызывает дополнительных проблем). С другой стороны, при отправке этих значений обратно клиенту, строку надо превратить в массив. Для таких целей служат методы `to_representation()` и `to_internal_value()`.

Предположим, что таким полем служит поле `sequence`:

```python
class TaskDetailSerializer(ModelSerializer):

    def to_representation(self, instance):
        rep = super().to_representation(instance)
        rep['sequence'] = [int(n) for n in rep['workScheme'].split(',')]
        return rep

    def to_internal_value(self, data):
        if 'sequence' in data:
            data['workScheme'] = str(data['workScheme']).replace('[', '').replace(']', '').replace(' ', '')
        return super().to_internal_value(data)

    class Meta:
        model = Task
        fields = "__all__"
```

>Если задать в поле fields значение "__all__", то будут включены все явно заданные поля модели.

# Routers (urls.py)

Маршрутизаторы прописываются в файлах urls.py. Они определяют, какие контроллеры из файлов views.py назначать тем или иным URL запросов. Маршруты определяются в списке `urlpatterns`:

```python
from django.urls import path
from .views import *

urlpatterns = [
    path("tasks/", TaskList.as_view(), name="tasks"),
    path("tasks/<int:pk>/", TaskDetail.as_view(), name="task"),
    path("vue_index/", vue_index, name="index"),
    path('', vue_index),
]
```

Указанные маршруты (*paths*) могут быть использованы в разных участках кода разных файлов, и вместо того, чтобы всюду вписывать url, создается для каждого path свое имя (`name`), которое и будет вписываться вместо url. Так, меняя url, нам не придется искать и менять его всюду, где мы его вписали, достаточно будет поменять его в urls.py, и он поменяется автоматически всюду, где вписано имя маршрута.

Первый путь (`tasks`) соответствует не праметризованному URL, в от время как вотрой путь (`task`) соответствует URL, параметризованному целым числом. В первом случае назначается контроллер `TaskList`, а во втором – `TaskDetail`. В тех случаях, когда контроллерами являются классы, при их назначении нужно вызывать методы `as_view()`.

В шаблоне параметра `<int:pk>/` указывается имя аргумента контроллера (`pk`), которому будет присвоено значение этого URL-параметра.

Пустая строка, переданная первым параметром (`route`) в функцию `path()`, обозначает корень пути из маршрута внешнего уровня вложенности (`/labor`). Т.е. контроллер `vue_index()` будет выполняться при запросе `localhost:8000/labor`.

## `include`

Функция `include()` из модуля `django.urls` позволяет включить текущий файл маршруты из других файлов urls.py:

```python
from django.urls import path, include
from django.urls import path, include

urlpatterns = [
    path('labor/', include('labor.urls')),
    path('api-auth/', include('rest_framework.urls', namespace='rest_framework')),
    path('rest-auth/', include('dj_rest_auth.urls')),
    path('rest-auth/registration', include('dj_rest_auth.registration.urls')),
]
```
