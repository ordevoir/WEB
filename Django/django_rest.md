# Установка и создание проекта

```
pip install django pillow djangorestframework
```

>Для конфигурации, использующей Python 3.6 и MySQL, можно сразу установить все необходимые библиотеки (включая библиотеки аутентификации):
>
>    ```
>    pip install pillow djangorestframework pymysql mysqlclient==1.4.6 dj-rest-auth django-allauth django-cors-headers
>    ```

# Настройка файлов и подключение БД

В файле **settings.py** прописываем в списке `INSTALLED_APPS: 'rest_framework'`, а в списке `DATABASES` подключаем базу данных. Инструкция в **django_using_SQL.md**.

В файле **urls.py** импортируем `include` и включаем `urls` для `rest`:

```python
from django.urls import include
path('api-auth/', include('rest_framework.urls', namespace='rest_framework'))
```

Для проверки можно запустить сервер (`python manage.py runserver`) и открыть в браузере http://localhost:8000/api-auth/login, залогиниться и затем зайти в админку http://localhost:8000/admin.

# Приложения в REST API

Во-первых, здесь не используется forms.py, так как вместо форм работают сериализаторы serializers.py. Во-вторых, отличается способ создания контроллеров: вместо формирования шаблонов, контроллеры REST формируют ответ в виде файла JSON, используя сериализаторы. 
Статические файлы, которые находятся в папке static, подключаются в конце файла settings.py.


# corsheaders

Изначально Django обрабатывает только те запросы, что пришли с того же домена, на котором располагается веб-служба. Однако, если мы хотим предоставить наш программный интерфейс любым сайтам и приложениям, нам понадобится разрешить фреймворку обрабатывать запросы, пришедшие с любых доменов. Проще всего сделать это, установив дополнительную библиотеку django-cors-headers:

```
pip install django-cors-headers
```

Программным ядром библиотеки django-cors-headers является приложение `corsheaders`. Необходимо добавить их в список `INSTALLED_APPS` файла настроек settings.py.

Кроме того, в список `MIDDLEWARE` нужно добавить посредники (в указанной последовательности):

```python
MIDDLEWARE = [
    ...
    'corsheaders.middleware.CorsMiddleware', 
    'django.middleware.common.CommonMiddleware',
]
```
Далее можно задать настройки библиотеки django-cors-headers:
```python
CORS_ALLOW_ALL_ORIGINS = True # раньше называлось 
```
>раньше параметр назывался `CORS_ORIGIN_ALLOW_ALL`

- `True` – Django будет обрабатывать запросы, приходящие с любого домена. 
- `False` – будут обрабатываться только запросы с текущего домена и с 
доменов, заданных в параметрах `CORS_ALLOWED_ORIGINS` (раньше называлось `CORS_ORIGIN_WHITELIST`) и `CORS_ALLOWED_ORIGIN_REGEXES` (раньше называлось `CORS_ORIGIN_REGEX_WHITELIST`). По умолчанию – `False`.

> подробнее [здесь](https://github.com/ottoyiu/django-cors-headers/) и в Дронов. Django 3.0. Установка и подготовка к работе Django REST framework
 

# Принцип работы REST

В клиентском запросе должны содержаться HTTP-method, URL [и body].

---

Список HTTP-методов:

- **GET** – выдача ресурса. Ресурс может представлять собой как последовательность каких либо сущностей, так и отдельную сущность;
- **POST** – создание нового ресурса;
- **PUT** – изменение значений всех полей у ресурса. Отметим, что при 
использовании этого метода фронтенд должен отправить бэкенду значения всех полей;
- **PATCH** – изменение отдельных полей у ресурса. В этом случае фронтенд может отправить бэкенду значения только тех полей, которые нужно исправить;
- **DELETE** – удаление ресурса.

---

URL представляет собой интернет-адрес. Маршрутизатор Django будет назначать контроллер, в соответствии с URL запроса. Так что это работает примерно так же как и в обычном Django.

Обычно, создание нового ресурса реализует тот же контроллер, который выдает ресурс-список сущностей (в обоих случаях в URL не указывается id конкретного ресурса), а исправление и удаление – тот же контроллер, который выдает отдельную сущность (в эти случаях в параметризованном URL должно содержаться id сущности). Поэтому для реализации всех этих действий достаточно записать всего два маршрута.

Сериализатор в Django REST framework выступает аналогом формы, работая с телом запроса и формируя тело ответа. 

>Подробне это описано в файле serializers.py

>Сохранение и удаление записей с помощью сериализаторов, связанных с моделями, выполняется точно так же, как и в случае применения связанных с моделями форм (`is_valid()`, `save()` и `delete()`).

Поля, которе нужно заполнить не из данных POST запроса, например, имя пользователя, можно передавать в сериализатор при сохранении:

```python
serializer.save(user=request.user)
```

Сериализация содержимого файла JSON осуществляется тем же 
классом-сериализатором, который сериализует объекты Python в JSON,однако в этом случае ему передаются данные запроса путем присваивания их именованному параметру `data`:

```python
serializer = SomeSerializer(data=request.data)
```

После успешного создания ресурса мы отсылаем фронтенду ответ с кодом `201` (ресурс успешно создан). Это выполняется передачей конструктору класса `Response` числового кода статуса посредством именованного параметра `status`: 

```python
return Response(serializer.data, status=status.HTTP_201_CREATED)
```

При успешном исправлении ресурса, отправленный клиенту ответ будет иметь код статуса по умолчанию: `200`. После успешного удаления ресурса клиент получит ответ с кодом статуса `204` (ресурс удален). Если же отправленные данные некорректны, то ответ с кодом `400` (некорректный запрос). Указанные коды статуса хранятся в переменных объявленных в модуле `rest_framework.status`:

- `HTTP_200_OK`
- `HTTP_201_CREATED`
- `HTTP_204_NO_CONTENT`
- `HTTP_400_BAD_REQUEST`

# Тестирование API

## Тестирование в браузере

Один из способов взаимодействия с API – использовать браузер. Если открыть в браузере URL, по локальному сереверу с хостом 8000 (например, `localhost:8000/labor/tasks/3`), то Django REST предоставит WEB интерфейс, для того, чтобы производить запросы и видеть получемые ответы.

Здесь, однако, может возникнуть некоторая проблема, если уже настроена система аутентификации: клиент в данном случае будет идентифицирован как `AnonymousUser`, и если требуется `id` пользователя, для того, чтобы взаимодействовать с БД, то возникнет ошибка:

    Field 'id' expected a number but got <django.contrib.auth.models.AnonymousUser object ...>


Решить эту проблему можно допустив в модели существование пустого значения в поле пользователя, задав параметр `null=True`:

```python
class Task(models.Model):
    ...
    user = models.ForeignKey(get_user_model(), null=True, on_delete=models.CASCADE, related_name='tasks')
    ...
```

Тогда, в контроллерах можно использовать значение `None` для объекта пользователя, если аутентификация не была произведена. Фактически это будет эквивалентно существованию ползователя `AnonymousUser`, но вместо его `id` или `username` будет в базе будет записано значение `NULL`.

Для того, чтобы проверить, была ли произведена аутентификация, можно посмотреть поле `is_authenticated` объекта пользователя, полученного из запроса. Используя условное выражение, можно присовить имени `user` объект пользователя, если аутентификация произведена, либо `None` в противном случае.

```python
    def get(self, request):
        user = request.user if request.user.is_authenticated else None
        tasks = Task.objects.filter(user=user)
        serializer = TaskSerializer(tasks, many=True)
```

## Тестирование с `requests`

Тестирование можно производить при помощи модуля `requests`:

```python 
import requests 

url = "http://localhost:8000/labor/tasks/"

response = requests.get(url)

print(response.status_code)
print(response.json())

```

При этом можно использовать токен, для аутентификации (если он уже получен):

```python 
token = "83c810fceb622802218cc98748f5b0b23d0a1cef"
response = requests.get(url, headers={"Authorization": f"Token {token}"})
```

