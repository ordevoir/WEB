# для того, чтобы управлять записями базы данных посредством
# скрипта, без необходимости вручную прописывать все комманды
# в django shell можно написать скрипт, затем запустить в shell

# пусть скрипт называется script.py

from labor.models import Status
# путь к файлу models должен быть указан относительно файла
# manage.py, независимо от того, где находится сам скрипт
status = Status(title='time_is_up')   # создается запись
status.save()                         # сохраняется запись

# для исполнения скрипта запускается django shell:
python manage.py shell

# и запускается функция исполнения скрипта:
exec(open('./labor/script.py').read())
# в предположении, что скрипт тоже находится в папке labor


# Создание записей

Запуск консоли Django
```
python manage.py shell 
```

Создадим первое объявление – первую запись в модели Bb:
>>> from bboard.models import Bb
>>> b1 = Bb(title='Дача', price=500000)
>>> b1.content = 'Садовое сообщество "Нарт". ' + 'два этажа, кирпич'

# Запись модели создается аналогично экземпляру любого другого класса 
# вызовом конструктора. Значения полей создаваемой записи можно указать 
# в вызове конструктора посредством именованных параметров, чьи имена 
# совпадают с именами соответствующих полей. Созданная таким образом 
# запись модели не сохраняется в базе данных, а существует только в 
# оперативной памяти. Чтобы сохранить ее, достаточно вызвать у нее метод 
# save() без параметров:

>>> b1.save()
>>> b1.pk # вывод значения ключевого поля (которое создалось автоматически)
>>> b1.published # вывод поля с записью даты и времени создания записи

# альтернативный способ создания записи:
>>> b1 = Bb.objects.create(title='Дача', price=500000)
# при этом для сохранения не нужно вызывать метод save()

# Диспетчер записей
# -----------------
# Все классы моделей поддерживают атрибут класса objects. Он хранит 
# диспетчер записей - особую структуру, позволяющую манипулировать всей 
# совокупностью имеющихся в модели записей. Диспетчер записей 
# представляется экземпляром класса Manager.

>>> for b in Bb.objects.all():
...     print(b.pk, ': ', b.title)

# Метод all() диспетчера записей возвращает так называемый набор записей 
# следовательность, содержащую записи модели. Сам набор записей 
# представляется экземпляром класса Queryset, а отдельные записи 
# экземплярами соответствующего класса модели. Поскольку набор записей 
# является последовательностью и поддерживает итерационный протокол, мы 
# можем перебрать его в цикле.

# Можно отсортировать записи по заголовку:
>>> for b in Bb.objects.order_by('title'):
...     print(b.pk, ': ', b.title)


# Можно и отфильтровать. Метод filter() возвращает другой диспетчер записей,
# содержащий только отфильтрованные записи.
>>> for b in Bb.objects.filter(title='Дача')
# для возвращения записей, содержащих кусок текста:
>>> for b in Bb.objects.filter(title__contains='а')

# Метод get() диспетчера записей имеет то же назначение, что и метод 
# fi1ter(), и вызывается аналогичным образом. Однако он ищет не все записи, 
# подходящие под заданные критерии, а лишь одну и возвращает ее в качестве 
# результата. К тому же, он работает быстрее метода filter().
>>> b = Bb.objects.get(pk=2) 
>>> b = Bb.objects.get(title__iexact='Дача') # регистронезависимый

# Метод delete() модели, как уже понятно, удаляет текущую запись и 
# возвращает сведения о количестве удаленных записей, обычно малополезные.
>>> b.delete()


# Формы
# -----
# Форма в терминологии Django это сущность, предназначенная для получения
# данных от посетителя и проверки их на корректность. Форма определяет набор
# полей, в которые будут вводиться отдельные значения, типы заносимых 
# значений, элементы управления, посредством которых будет осуществляться 
# ввод данных, и правила валидации.

# Форма , связанная с моделью (forms.ModelForm), отличается от обычной 
# формы (forms.Form) тем, что представляет какую-либо запись модели уже
# существующую или еще не существующую. В частности, поля такой формы 
# соответствуют одноименным полям модели. Помимо этого, такая форма 
# поддерживает метод save(), вызвав который, мы с легкостью сохраним
# занесенные в форму данные в информационной базе.




# Шаблоны
# -------
# Шаблон (template) это образец для формирования документа, который будет 
# представлен клиенту: веб-страницы, файла в формате XML, PDF и пр. 
# Подсистема Django, называемая шаблонизатором, загружает шаблон, 
# объединяет его с данными, извлеченными из моделей, полученными от 
# посетителя или сгенерированными в процессе работы, и формирует на основе 
# всего этого полноценный документ, который и отправляется клиенту.

# По умолчанию шаблонизатор ищет все шаблоны в папках templates, вложенных
# в папки пакетов приложений.

# Применительно к веб-страницам, шаблон это файл с НТМL-кодом страницы,
# содержащий особые команды шаблонизатора: директивы, теги и фильтры. 
# - Директивы указывают поместить в заданное место НТМL-кода какое-либо 
#   значение 
# - Tеги управляют генерированием содержимого результирующего документа
# - Фильтры выполняют преобразования указанного значения перед выводом.

# Тег шаблонизатора:

{{ statement }}     # значения
{% expression %}    # выражения

{% extends 'labor/basic_labor.html' %} 
# данный шаблон будет расширением шаблона basic_labor.html

# данные внутри выражений типа
{% block title %}   # блок с названием title
    Activity Type list - {{ block.super }}
{% endblock %}
# вставляются внутрь аналогичных выражений базового шаблона (с названием
# title), заменяя их содержимое, которое выводилось бы, если бы шаблон-
# наследник не вставил в блок другие данные

# использование фильтра, ограничивающего количество слов:
{{ task.discribe|truncatewords:5 }}

{% for bb in bbs %} # На каждом проходе он извлекает из последовательности, 
. . . . . . .       # хранящейся в переменной bbs, очередной элемент, 
{% endfor %}        # заносит его в переменную bb.

# ссылка содержит url, с непосредственным указанием пути маршрута:
<a href="{% url 'tags/' %}" class=""></a>
# ссылка содержит url, с указанием имени пути маршрута:
<a href="{% url 'tags_list_url' %}" class=""></a>

<form action="{% url 'tag_create_url' %}" method="post">
# action - это атрибут, указывающий на обработчик данной формы
# (к маршруту с именем tags_list_url привязан свой обработчик)
# method="post" подразумевает, что после того, как мы нажмем
# кнопку с типом submit, данные формы улетят на обработку
    {% csrf_token %}
    # при генерации шаблона в файле view.py (класс TagCreate) в html файл 
    # передается context - словарь с данными, которые будут использованы в 
    # шаблоне. в данном случае словарь содержит ключ form, которому присвоен
    # объект формы, т.е. form содержит поля, которые перебираются в цикле
    # и выводятся нужным образом:
    {% for field in form %}
        <div class="form-group">
            {% if field.errors %}   # если будут ошибки, в частности, если
                <div class="alert alert-danger">    # тег уже существует,
                    {{ field.errors }}              # будет выводится ошибка
                </div>                              # указанная в валидаторе
            {% endif %}

            {{ field.label }}   # название поля
            {{ field }}         # виджет поля
            # тип виджета а так же его атрибуты (например, класс) могут быть
            # определены в формах (см. файл forms.py  ->  class TagForm)
        </div>
    {% endfor %}
</form>

{{ bb.title }}  # указывает извлечь значение из атрибута title объекта, 
                # хранящегося в созданной упомянутым ранее тегом переменной 
# bb, и вставить это значение в то место кода, в котором находится она сама

# Фильтр date:

{{ bb.published|date:"d.m.Y H:i:s" }} # преобразует значение из атрибута
#                                       published объекта, хранящегося в
# переменной bb, т.е. дату и время публикации объявления, в формат, 
# собственно, даты и времени. Сам формат, в который нужно преобразовать 
# значение, указывается в параметре фильтра в виде строки.



# Наследование шаблонов
# ---------------------
# Django предоставляет механизм, позволяющий реализовать наследование
# шаблонов. Шаблон, являющийся базовым, объявляет в составе своего 
# содержимого так называемые блоки. Они определяют место в шаблоне, куда 
# будет вставлено содержимое, извлеченное из шаблонов, которые станут
# производными по отношению к базовому. Каждый из блоков имеет уникальное 
# в пределах шаблона имя. В нашем примере базовый шаблон basic.html
# расополагается в папке layout. Шаблоны index.html, by_rubric.html и
# create.html являются производнымим от шаблона basic.html


# Статические файлы
# -----------------
# Файлы, содержимое которых не обрабатывается программно, а пересылается 
# клиенту как есть, в терминологии Django носят название статических. 
# К таким файлам относятся, например, таблицы стилей и графические 
# изображения, помещаемые на страницы. По умолчанию Django требует, чтобы 
# статические файлы, относящиеся к определенному приложению, помещались 
# в папке static пакета этого приложения (такое поведение можно изменить).
