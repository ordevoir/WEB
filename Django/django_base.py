# Установка и создание проекта
# ----------------------------
pip install django # install django

django-admin startproject <name> # create project

manage.py # программный файл с кодом одноименной утилиты, с использовани­ем
# которой производятся различные действия над самим проектом. Впрочем,
# единственное, чем она занивается - вызывает утилиту django-admin, 
# передавая ей все полученные комманды и конфигурируя ее для обработки
# текущего проекта.

settings.py # модуль с настройками самого проекта. Включает описание
# конфигурации базы данных проекта, пути ключевых папок, важные параметры, 
# связанные с безопасностью, и пр.

urls.py # модуль с маршрутами уровня проекта.

wsgi.py # модуль, связывающий проект с веб-сервером

# Приложения
# ----------
# Приложение в терминологии Django это отдельный фрагмент функциональности 
# разрабатываемого сайта, более или менее независимый от других таких же 
# фрагментов и входящий в состав проекта. Приложение может реализовывать 
# работу целого сайта, его раздела или же какой-либо внутренней подсистемы 
# сайта, используемой другими приложениями. Создание нового приложения:
python manage.py startapp <app_name> # запускается с директории проекта

# Любое приложение представляется обычным пакетом Python(пакет приложения), 
# в котором находятся модули с программным кодом. Этот пакет находится в 
# папке проекта там же, где располагается пакет конфигурации. Имя пакета 
# приложения станет именем самого приложения.

# Регистрирование созданного приложения. В файле setting.py в список
# INSTALLED_APPS, вписываем '<app_name>.apps.App_nameConfig'.

python manage.py runserver # запускает веб-сервер, http://localhost:8000/

# Контроллеры (views)
# -------------------
# Контроллер это код, запускаемый в ответ на поступление клиентского 
# запроса, который содержит интернет-адрес определенного формата. Именно в
# контроллерах выполняются все действия по подготовке данных для вывода, 
# ровно как и обработка данных, поступивших от посетителя.

# Для хранения кода контроллеров изначально предназначается модуль views.py
# в файле views.py показано, как создается контроллер...  

# Представления (Маршруты и маршрутизатор) 
# ----------------------------------------
# Маршрутизация в терминах Django это процесс выяснения, какой контроллер
# следует выполнить при получении в составе клиентского запроса интернет-
# адреса определенного формата. Подсистема фреймворка, выполняющая 
# маршрутизацию, носит название маршрутизатора.
# При поступлении любого запроса от клиента Django разбирает его на 
# составные части (чем занимается целая группа программных модулей, 
# называемых посредниками), извлекает запрошенный посетителем интернет-
# адрес, удаляет из него все составные части, за исключением пути, который 
# передает маршрутизатору. Последний последовательно сравнивает его с 
# шаблонными адресами, записанными в списке маршрутов. Как только будет 
# найдено совпадение, маршрутизатор выясняет, какой контроллер связан с 
# совпавшим шаблонным адресом, и передает этому контроллеру управление.
# в файлах \samplesite\urls.py, \bboard\urls.py последоваельно показано, 
# как создаются списки маршрутов... 

# Модели
# ------
# Модель это однозначное и исчерпывающее описание сущности, хранящейся
# в базе данных в виде класса Python. Класс модели описывает таблицу базы 
# данных, в которой будет храниться набор сущностей, и содержит атрибуты 
# класса, каждый из которых описывает одно из полей этой таблицы. Т.о.
# модель - это представление таблицы и ее полей средствами Python.
# Отдельный экземпляр класса модели представляет отдельную конкретную 
# сущность, извлеченную из базы, т. е. отдельную запись соответствующей 
# таблицы. Пользуясь объявленными в модели атрибутами класса, мы можем 
# получать значения, хранящиеся в полях записи, равно как и записывать в 
# них новые значения. Помимо этого, класс модели предоставляет инструменты 
# для выборки сущностей из базы, их фильтрации и сортировки на основе 
# заданных критериев. Полученный результат представляется в виде 
# последовательности экземпляров класса модели. Модели объявляются на 
# уровне приложения. Объявляющий их код должен записываться в модуль 
# models.py пакета приложения. Изначально этот модуль пуст.

# Миграции
# --------
# Миграция - это модуль Python, созданный самим Django на основе опред-ной 
# модели и предназначенный для формирования в базе данных всех требуемых 
# этой моделью структур: таблиц, полей, индексов, правил и связей.
# Команда makemigrations утилиты manage.py запускает генерирование миграций
# для всех моделей, объявленных в приложении, чье имя записано после самой
# команды, и не изменившихся с момента предыдущего генерирования миграций.

python manage.py makemigrations <app_name>

# Сформированные таким образом модули с миграциями сохранябтся в пакете
# migragions, находящемся в пакете приложения (0001_initial.py).

# Миграция при выполнении порождает команды на языке SQL, которые будут 
# отправлены СУБД и, собственно, выполнят все действия по созданию 
# необходимых структур данных.
# Посмотреть на результирующий SQL-код нашей миграции, можно командой
python manage.py sqlmigrate <app_name> XXXX # где XXXX - код миграции...   

# Выполнение всех миграций всех приложений:
python manage.py migrate

# при программировании реальных сайтов настоятельно рекомендуется исключать 
# ненужные стандартные приложения из списка зарегистрированных в проекте.


# Создание записей
# ----------------
python manage.py shell # запуск консоли Django

# создадим первое объявление - первую запись в модели Bb:
>>> from bboard.models import Bb
>>> b1 = Bb(title='Дача', price=500000)
>>> b1.content = 'Садовое сообщество "Нарт". ' + 'два этажа, кирпич'

# Запись модели создается аналогично экземпляру любого другого класса 
# вызовом конструктора. Значения полей создаваемой записи можно указать 
# в вызове конструктора посредством именованных параметров, чьи имена 
# совпадают с именами соответствующих полей. Созданная таким образом 
# запись модели не сохраняется в базе данных, а существует только в 
# оперативной памяти. Чтобы сохранить ее, достаточно вызвать у нее метод 
# save() без параметров:

>>> b1.save()
>>> b1.pk # вывод значения ключевого поля (которое создалось автоматически)
>>> b1.published # вывод поля с записью даты и времени создания записи

# альтернативный способ создания записи:
>>> b1 = Bb.objects.create(title='Дача', price=500000)
# при этом для сохранения не нужно вызывать метод save()

# Диспетчер записей
# -----------------
# Все классы моделей поддерживают атрибут класса objects. Он хранит 
# диспетчер записей - особую структуру, позволяющую манипулировать всей 
# совокупностью имеющихся в модели записей. Диспетчер записей 
# представляется экземпляром класса Manager.

>>> for b in Bb.objects.all():
...     print(b.pk, ': ', b.title)

# Метод all() диспетчера записей возвращает так называемый набор записей 
# следовательность, содержащую записи модели. Сам набор записей 
# представляется экземпляром класса Queryset, а отдельные записи 
# экземплярами соответствующего класса модели. Поскольку набор записей 
# является последовательностью и поддерживает итерационный протокол, мы 
# можем перебрать его в цикле.

# Можно отсортировать записи по заголовку:
>>> for b in Bb.objects.order_by('title'):
...     print(b.pk, ': ', b.title)


# Можно и отфильтровать. Метод filter() возвращает другой диспетчер записей,
# содержащий только отфильтрованные записи.
>>> for b in Bb.objects.filter(title='Дача')
# для возвращения записей, содержащих кусок текста:
>>> for b in Bb.objects.filter(title__contains='а')

# Метод get() диспетчера записей имеет то же назначение, что и метод 
# fi1ter(), и вызывается аналогичным образом. Однако он ищет не все записи, 
# подходящие под заданные критерии, а лишь одну и возвращает ее в качестве 
# результата. К тому же, он работает быстрее метода filter().
>>> b = Bb.objects.get(pk=2) 
>>> b = Bb.objects.get(title__iexact='Дача') # регистронезависимый

# Метод delete() модели, как уже понятно, удаляет текущую запись и 
# возвращает сведения о количестве удаленных записей, обычно малополезные.
>>> b.delete()


# Формы
# -----
# Форма в терминологии Django это сущность, предназначенная для получения
# данных от посетителя и проверки их на корректность. Форма определяет набор
# полей, в которые будут вводиться отдельные значения, типы заносимых 
# значений, элементы управления, посредством которых будет осуществляться 
# ввод данных, и правила валидации.

# Форма , связанная с моделью (forms.ModelForm), отличается от обычной 
# формы (forms.Form) тем, что представляет какую-либо запись модели уже
# существующую или еще не существующую. В частности, поля такой формы 
# соответствуют одноименным полям модели. Помимо этого, такая форма 
# поддерживает метод save(), вызвав который, мы с легкостью сохраним
# занесенные в форму данные в информационной базе.


# Административный сайт
# ---------------------
# Административный веб-сайт предоставляет доступ ко всем моделям, 
# объявленным во всех приложениях, что составляют проект. Мы можем 
# просматривать, добавлять, править и удалять записи, выполнять их 
# фильтрацию и сортировку. Помимо этого, административный сайт не 
# пускает к данным сайта посторонних, используя для этого встроенную 
# во фреймворк подсистему разграничения доступа.
# Эта подсистема реализована в стандартном приложении 
# django.contrib.auth. А работу самого административного сайта 
# обеспечивает стандартное приложение django.contrib.admin. Оба этих 
# приложения заносятся в список зарегистрированных в проекте изначально.
# Стандартное приложение использует django.contrib.auth для хранения 
# списков зарегистрированных пользователей, групп и прав особые модели. 
# Для них в базе данных должны быть созданы таблицы, и создание этих 
# таблиц выполняют особые миграции.
# Редактор модели позволяет изменить параметры представления модели на 
# административном сайте. Редактор объявляется в модуле административных
# настроек admin.py пакета приложения. Подробнее в файле admin.py.

# создать зарегистрированного пользователя сайта с максимальными правами
python manage.py createsuperuser
# чтобы приложение bboard появилось в списке приложений на административном
# сайте, необходимо импортировать класс Bb и зарегистрировать его в файле
# bboard/admin.py


# Шаблоны
# -------
# Шаблон (template) это образец для формирования документа, который будет 
# представлен клиенту: веб-страницы, файла в формате XML, PDF и пр. 
# Подсистема Django, называемая шаблонизатором, загружает шаблон, 
# объединяет его с данными, извлеченными из моделей, полученными от 
# посетителя или сгенерированными в процессе работы, и формирует на основе 
# всего этого полноценный документ, который и отправляется клиенту.

# По умолчанию шаблонизатор ищет все шаблоны в папках templates, вложенных
# в папки пакетов приложений.

# Применительно к веб-страницам, шаблон это файл с НТМL-кодом страницы,
# содержащий особые команды шаблонизатора: директивы, теги и фильтры. 
# - Директивы указывают поместить в заданное место НТМL-кода какое-либо 
#   значение 
# - Tеги управляют генерированием содержимого результирующего документа
# - Фильтры выполняют преобразования указанного значения перед выводом.

# Тег шаблонизатора:

{{ statement }}     # значения
{% expression %}    # выражения

{% extends 'labor/basic_labor.html' %} 
# данный шаблон будет расширением шаблона basic_labor.html

# данные внутри выражений типа
{% block title %}   # блок с названием title
    Activity Type list - {{ block.super }}
{% endblock %}
# вставляются внутрь аналогичных выражений базового шаблона (с названием
# title), заменяя их содержимое, которое выводилось бы, если бы шаблон-
# наследник не вставил в блок другие данные

# использование фильтра, ограничивающего количество слов:
{{ task.discribe|truncatewords:5 }}

{% for bb in bbs %} # На каждом проходе он извлекает из последовательности, 
. . . . . . .       # хранящейся в переменной bbs, очередной элемент, 
{% endfor %}        # заносит его в переменную bb.

# ссылка содержит url, с непосредственным указанием пути маршрута:
<a href="{% url 'tags/' %}" class=""></a>
# ссылка содержит url, с указанием имени пути маршрута:
<a href="{% url 'tags_list_url' %}" class=""></a>

<form action="{% url 'tag_create_url' %}" method="post">
# action - это атрибут, указывающий на обработчик данной формы
# (к маршруту с именем tags_list_url привязан свой обработчик)
# method="post" подразумевает, что после того, как мы нажмем
# кнопку с типом submit, данные формы улетят на обработку
    {% csrf_token %}
    # при генерации шаблона в файле view.py (класс TagCreate) в html файл 
    # передается context - словарь с данными, которые будут использованы в 
    # шаблоне. в данном случае словарь содержит ключ form, которому присвоен
    # объект формы, т.е. form содержит поля, которые перебираются в цикле
    # и выводятся нужным образом:
    {% for field in form %}
        <div class="form-group">
            {% if field.errors %}   # если будут ошибки, в частности, если
                <div class="alert alert-danger">    # тег уже существует,
                    {{ field.errors }}              # будет выводится ошибка
                </div>                              # указанная в валидаторе
            {% endif %}

            {{ field.label }}   # название поля
            {{ field }}         # виджет поля
            # тип виджета а так же его атрибуты (например, класс) могут быть
            # определены в формах (см. файл forms.py  ->  class TagForm)
        </div>
    {% endfor %}
</form>

{{ bb.title }}  # указывает извлечь значение из атрибута title объекта, 
                # хранящегося в созданной упомянутым ранее тегом переменной 
# bb, и вставить это значение в то место кода, в котором находится она сама

# Фильтр date:

{{ bb.published|date:"d.m.Y H:i:s" }} # преобразует значение из атрибута
#                                       published объекта, хранящегося в
# переменной bb, т.е. дату и время публикации объявления, в формат, 
# собственно, даты и времени. Сам формат, в который нужно преобразовать 
# значение, указывается в параметре фильтра в виде строки.



# Наследование шаблонов
# ---------------------
# Django предоставляет механизм, позволяющий реализовать наследование
# шаблонов. Шаблон, являющийся базовым, объявляет в составе своего 
# содержимого так называемые блоки. Они определяют место в шаблоне, куда 
# будет вставлено содержимое, извлеченное из шаблонов, которые станут
# производными по отношению к базовому. Каждый из блоков имеет уникальное 
# в пределах шаблона имя. В нашем примере базовый шаблон basic.html
# расополагается в папке layout. Шаблоны index.html, by_rubric.html и
# create.html являются производнымим от шаблона basic.html


# Статические файлы
# -----------------
# Файлы, содержимое которых не обрабатывается программно, а пересылается 
# клиенту как есть, в терминологии Django носят название статических. 
# К таким файлам относятся, например, таблицы стилей и графические 
# изображения, помещаемые на страницы. По умолчанию Django требует, чтобы 
# статические файлы, относящиеся к определенному приложению, помещались 
# в папке static пакета этого приложения (такое поведение можно изменить).


