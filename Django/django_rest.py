# установка django:
pip install django pillow djangorestframework

# создание нового приложения:
django-admin startproject <name>

# прописываем в settings.py в списке INSTALLED_APPS: 'rest_framework',

# а в списке DATABASES подключаем базу данных

# в url.py импортируем include и подключаем url для rest в url.py:
from django.urls import include
path('api-auth/', include('rest_framework.urls', namespace='rest_framework'))

# создаем суперпользователя:
python manage.py createsuperuser
username: drosophila
email:
password: micromatosis

# для проверки можно запустить сервер и открыть в браузере
http://localhost:8000/api-auth/login
# залогиниться и затем зайти в админку:
http://localhost:8000/admin

# создаем приложение, в случае maxwell_rest я просто скопировал папку
# labor из приложения maxwell, удалил там все миграции, все url в 
# файле urls.py, очистил все содержимое файла views.py
# так же удалил forms.py т.к. вместо форм будут работать сериализаторы

# название приложения (labor) добавил в INSTALLED_APPS файла settings.py
# скопировал папку static из приложения maxwell и так же подключил его
# в конце файла settings.py, аналогично тому, как это сделано в maxwell

# выполнил миграции, чтобы модели создали таблицы в базе данных:
python manage.py makemigrations
python manage.py migrate

# теперь на сайте админки можно убедиться в том, что модели созданы

# модели создаются аналогично обычному djangо
# вместо форм создаются сериализаторы в файле serializers.py
# отдельно пишутся контроллеры в views.py, использующие сериализаторы
# в urls.py прописываются маршруты к контроллерам

# Изначально Django обрабатывает только те запросы, что пришли с 
# того же домена, на котором располагается веб-служба. Однако, если 
# мы хотим предоставить наш программный интерфейс любым сайтам и 
# приложениям, нам понадобится разрешить фреймворку обрабатывать 
# запросы, пришедшие с любых доменов. Проще всего сделать это, 
# установив дополнительную библиотеку django-cors-headers:
pip install django-cors-headers

# Программным ядром библиотеки django-cors-headers является приложение
# corsheaders. Необходимо добавить их в список INSTALLED_APPS (settings.py)

# Кроме того, в параметр MIDDLEWARE нужно добавить посредники
'corsheaders.middleware.CorsMiddleware',        # в указанной
'django.middleware.common.CommonMiddleware',    # последовательности

# настройки библиотеки django-cors-headers (в settings.py)
CORS_ALLOW_ALL_ORIGINS = True # раньше называлось CORS_ORIGIN_ALLOW_ALL
# True - Django будет обрабатывать запросы, приходящие с любого домена. 
# False - будут обрабатываться только запросы с текущего домена и с 
# доменов, заданных в параметрах CORS_ALLOWED_ORIGINS (раньше называлось
# CORS_ORIGIN_WHITELIST) и CORS_ALLOWED_ORIGIN_REGEXES (раньше наз-ось
# CORS_ORIGIN_REGEX_WHITELIST). По умолчанию — False.

# подробнее:
# (Дронов. Django 3.0. Установка и подготовка к работе Django REST framework)
# https://github.com/ottoyiu/django-cors-headers/

# Принцип работы REST:
# В клиентском запросе должны содержаться method, url [и body]
# 
# method - HTTP-метод:
# GET - выдача ресурса. Ресурс может представлять собой как перечень 
#   какихлибо сущностей, так и отдельную сущность;
# POST - создание нового ресурса;
# PUT - исправление значений всех полей у ресурса. Отметим, что при 
#   использовании этого метода фронтенд должен отправить бэкенду 
#   значения всех полей;
# PATCH - исправление отдельных полей у ресурса. В этом случае фронтенд
#   может отправить бэкенду значения только тех полей, которые нужно 
#   исправить;
# DELETE - удаление ресурса
# 
# url представляет собой интернет-адрес. Маршрутизатор django будет
# назначать контроллер, в соответствии с url запроса. Так что это
# работает примерно так же как и в обычном django
# 
# Обычно создание нового ресурса реализует тот же контроллер, который
# выдает ресурс-список сущностей (в обоих случаях в url не указывается id
# конкретного ресурса), а исправление и удаление — тот же контроллер, 
# который выдает ресурс-отдельную сущность (в эти случаях в параметри-
# зованном url должно содержаться id сущности). Поэтому для реализации 
# всех этих действий достаточно записать всего два маршрута.
# 
# Сериализатор в Django REST framework выступает аналогом формы. 
# Подробне это описано в файле serializers.py
# 
# Сохранение и удаление записей с помощью сериализаторов, связанных с 
# моделями, выполняется точно так же, как и в случае применения связанных 
# с моделями форм (is_valid(), save() и delete()).
# 
# Поля, которе нужно заполнить не из данных POST запроса, например, имя
# пользователя, можно передавать в сериализатор при сохранении:
serializer.save(user=request.user)
# 
# Сериализация содержимого json осуществляется тем же 
# классом-сериализатором, который сериализует объекты python в json,
# однако в этом случае ему передаються данные запроса путем присваивания
# их именованному параметру data (data=request.data)
serializer = SomeSerializer(data=request.data)
# После успешного создания рубрики мы отсылаем фронтенду ответ с кодом 201
# (ресурс успешно создан). Это выполняется передачей конструктору класса 
# Response числового кода статуса посредством именованного параметра status:
return Response(serializer.data, status=status.HTTP_201_CREATED)
# При успешном исправлении рубрики отправленный клиенту ответ будет иметь 
# код статуса по умолчанию: 200. После успешного удаления рубрики клиент 
# получит ответ с кодом статуса 204 (ресурс удален). Если же отправленные 
# данные некорректны, то ответ с кодом 400 (некорректный запрос). Указанные
# коды статуса хранятся в переменных объявленных в модуле rest_framework.status
HTTP_200_OK
HTTP_201_CREATED
HTTP_204_NO_CONTENT
HTTP_400_BAD_REQUEST
