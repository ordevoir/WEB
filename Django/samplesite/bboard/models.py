from django.db import models

# Сама модель должна быть подклассом класса Model из модуля django.db.models.
# Отдельным полям модели присваиватся экземпляры классов, представляющих
# поля разных типов и объявленных в том же модуле django.db.models. 
# Параметры полей указываются в конструкторах классов полей в виде значений
# именнованных параметров:

class Bb(models.Model):
    title = models.CharField(max_length=50, verbose_name='Title')
    content = models.TextField(null=True, blank=True, verbose_name='Discribtion')
    price = models.FloatField(null=True, blank=True, verbose_name='Price')
    published = models.DateTimeField(auto_now_add=True, db_index=True, verbose_name='Published')

# CharField - обычное строковое поле фиксированной длины max_lenght.
# TextField - текстовое поле неограниченной длины, или memo-поле.
# FloatField - поле для хранения вещественных чисел.
# DataTimeField - поле для хранения отметки даты и времени. 
#   Присвоив параметру auto_now_add конструктора значение True, мы 
#   предпишем Django при создании новой записи записывать в это поле текущие
#   дату и время. А параметр db_index при присваивании ему значения True 
#   укажет создать для этого поля индекс (при выводе объявлений мы будем 
#   сортировать их по убыванию даты публикации, и индекс здесь пригодится).
#   blank=True позволяет остаялять поле поле пустым; если при этом null=True
#   то при этому в базу будет записываться значение NULL

    rubric = models.ForeignKey('Rubric', null=True,     # поле внешнего
    on_delete=models.PROTECT, verbose_name='Rubric')    # ключа

# Класс ForeignКey представляет поле внешнего ключа, в котором фактически 
# будет храниться ключ записи из первичной модели. Первым параметром 
# конструктору этого класса передается класс первичной модели в виде:
# - ссылки на класс если код, объявляющий класс первичной модели, 
#   располагается перед кодом класса вторичной модели;
# - строки с именем класса если вторичная модель объявлена раньше первичной
# Именованный параметр on_delete управляет каскадными удалениями записей 
# вторичной модели после удаления записи первичной модели, с которой они 
# бьmи связаны. Значение РRОТЕСТ запрещает каскадные удаления

# выполним генерирование миграций, которые внесут необходимые изменения 
# в структуры базы данных: python manage.py makemigrations bboard. Новая 
# миграция создаст таблицу для модели Rubric и добавит в таблицу модели 
# Bb новое поле rubric. Выполним созданную миграцию: python manage.py migrate

    class Meta:
        # название модели:
        verbose_name_plural = 'Callboards'  # во множественном числе
        verbose_name = 'Callboard'          # в единственном числе
        ordering = ['-published']   # сортировка записей:

# По умолчанию вновь созданный проект Django настроен на использование базы
# данных в формате SQLite, хранящейся в файле db.sqliteЗ. Эта база данных 
# будет создана уже при первом запуске отладочного веб-сервера.

class Rubric(models.Model): # модель рубрики
    name = models.CharField(max_length=20, db_index=True, verbose_name = 'Name')
    # переопределим метод __str__(), возвращающий строковое представление
    # класса. Теперь будет выводиться на административном сейте нащвение
    # рубрики вместо Rubric(1), Rubric(2) и т.д.
    def __str__(self):
        return self.name
    class Meta:
        verbose_name_plural = 'Rubrics'
        verbose_name = 'Rubric'
        ordering = ['name']

# новую модель нужно зарегистрировать на административном сайте, добавив
# в модуль admin.py пакета приложений такие два выражения:
# form .models import Rubric
# admin.site.register(Rubric)