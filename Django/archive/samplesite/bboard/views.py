from django.shortcuts import render
from django.http import HttpResponse

# from django.template import loader

from .models import Bb, Rubric

def index(request): # контроллер-функция
  # загружаем шаблон; результатом, возвращенным функцией будет экземпляр
  # класса Template, представляющий этот шаблон:
    # template = loader.get_template('bboard/index.html')
  
  # получим list записей отсортированные по убыванию даты их публикации:
    bbs = Bb.objects.order_by('-published')
  
  # формируется контекст шаблона:
    rubrics = Rubric.objects.all()
    context = {'bbs': bbs, 'rubrics': rubrics}
  # region
  # Контекстом шаблона называется набор данных, которые должны быть 
  # доступны внутри шаблона в виде переменных и с которыми шаблонизатор 
  # объединит этот шаблон для получения выходного документа. Контекст 
  # шаблона должен представлять собой обычный словарь Python, ключи 
  # элементов которого станут переменными, доступными в шаблоне, а
  # значения элементов значениями этих переменных. В нашем случае 
  # контекст шаблона будет содержать только переменную ЬЬs, где хранится 
  # список объявлений.
  
  # выполняем обработку шаблона, в процессе которой шаблонизатор 
  # выполняет объединение его с данными из контекста (рендеринг)
    # return HttpResponse(template.render(context, request))
  # результат, возвращенный методом и представляющий собой строку 
  # с НТМL-кодом готовой веб-страницы, мы передаем конструктору класса
  # HttpResponse для формирования ответа.
  # endregion

    # запишем index(request) через функции-сокращения (shortcuts):
    return render(request, 'bboard/index.html', context)

# Любая контроллер-функция в качестве единственного обязательного параметра
# принимает экземпляр класса HttpRequest, хранящий различные сведения о 
# полученном запросе: запрашиваемый интернет-адрес, данные, полученные от 
# посетителя, служебную информацию от самого веб-обозревателя и пр. 
# По традиции этот параметр называется request. 
# В данном случае мы его никак не используем.

# В теле функции мы создаем экземпляр класса нttpResponse (он объявлен в 
# модуле django.http), который будет представлять отправляемый клиенту ответ. 
# Содержимое этого ответа собственно текстовое сообщение мы указываем 
# единственным параметром конструктора этого класса. Готовый экземпляр 
# класса мы возвращаем из функции в качестве результата.

# Чтобы при наборе интернет-адреса http://localhost:8000/bboard/ запускался 
# только что написанный нами контроллер-функция index(), нам нужно связать
# таковой с шаблонным адресом bboard/. (см. в файле urls.py)

# При создании экземпляра класса HttpResponse, представляющего отсылаемый 
# клиенту ответ, мы в именованном параметре content_type конструктора 
# указали тип отправляемых данных: обычный текст, набранный в кодировке 
# UTF-8 (если мы этого не сделаем, веб-обозреватель посчитает текст 
# НТМL-кодом и выведет его одной строкой, скорее всего, в нечитаемом виде).

# контроллер, прденазначенный для обработки параметризованного запроса
def by_rubric(request, rubric_id):
  # переменной rubric_id будет присвоено значение URL-параметра, выбранное
  # из интернет-адреса
    bbs = Bb.objects.filter(rubric=rubric_id)
    rubrics = Rubric.objects.all() # все рубрики для панели навигации
    current_rubric = Rubric.objects.get(pk=rubric_id)
    context = {'bbs': bbs, 'rubrics': rubrics, 'current_rubric': current_rubric}
    return render(request, 'bboard/by_rubric.html', context)

# создадим высокоуровневый контроллер-класс, который возьмет большую
# часть действий по выводу и обработке действий формы BbForm на себя.

from django.views.generic.edit import CreateView
from .forms import BbForm
from django.urls import reverse_lazy

# Базовый класс CreateView реализует функциональность по созданию формы, 
# выводу ее на экран с применением указанного шаблона, получению занесенных 
# в форму данных, проверке их на корректность, сохранению их в новой записи 
# модели и перенаправлению в случае успеха на интернет-адрес, который мы 
# зададим.
class BbCreateView(CreateView):
    template_name = 'bboard/create.html' # путь к файлу шаблона формы
    form_class = BbForm   # cам класс формы, связанный с моделью
    success_url = reverse_lazy('index')  # интернет-адрес, по которому будет
    # выполнено перенаправление после успешного сохранения данных; 
    # функция reverse_lazy() из модуля django.urls в качестве параметров 
    # принимает имя маршрута и значения всех входящих в маршрут URL-параметров 
    # (если они там есть). Результатом станет готовый интернет-адрес.

    def get_context_data(self, **kwargs):
        """ Метод get_context_data() этого класса формирует контекст 
            шаблона. Мы переопределили метод, чтобы добавить в контекст 
            дополнительные данные рубрик (для панели навигации). В теле 
            этого метода мы сначала получаем контекст шаблона от метода 
            базового класса, затем добавляем в него список рубрик и, 
            наконец, возвращаем в качестве результата """
        context = super().get_context_data(**kwargs)
        context['rubrics'] = Rubric.objects.all()
        return context